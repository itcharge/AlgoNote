# [0661. 图片平滑器](https://leetcode.cn/problems/image-smoother/)

- 标签：数组、矩阵
- 难度：简单

## 题目链接

- [0661. 图片平滑器 - 力扣](https://leetcode.cn/problems/image-smoother/)

## 题目大意

**描述**：

「图像平滑器」是大小为 $3 \times 3$ 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。

每个单元格的「平均灰度」定义为：该单元格自身及其周围的 $8$ 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 $9$ 个单元格的平均值）。

如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 $4$ 个单元格的平均值）。

![](https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg)

给定一个表示图像灰度的 $m \times n$ 整数矩阵 $img$。

**要求**：

返回对图像的每个单元格平滑处理后的图像。

**说明**：

- $m == img.length$。
- $n == img[i].length$。
- $1 \le m, n \le 200$。
- $0 \le img[i][j] \le 255$。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg)

```python
输入:img = [[1,1,1],[1,0,1],[1,1,1]]
输出:[[0, 0, 0],[0, 0, 0], [0, 0, 0]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg)

```python
输入: img = [[100,200,100],[200,50,200],[100,200,100]]
输出: [[137,141,137],[141,138,141],[137,141,137]]
解释:
对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
```

## 解题思路

### 思路 1：矩阵遍历

这道题目要求对图像的每个单元格进行平滑处理，计算该单元格及其周围 8 个单元格的平均值（向下取整）。

1. 创建一个与原图像大小相同的结果矩阵 $result$。
2. 定义 8 个方向的偏移量，用于访问当前单元格周围的 8 个单元格。
3. 遍历图像的每个单元格 $(i, j)$：
   - 初始化 $sum$ 为当前单元格的值，$count$ 为 1。
   - 遍历 8 个方向，检查相邻单元格是否在边界内。
   - 如果在边界内，将该单元格的值累加到 $sum$，并将 $count$ 加 1。
   - 计算平均值 $sum // count$（向下取整），存入结果矩阵。
4. 返回结果矩阵。

### 思路 1：代码

```python
class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        m, n = len(img), len(img[0])
        result = [[0] * n for _ in range(m)]
        
        # 8 个方向的偏移量
        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        
        for i in range(m):
            for j in range(n):
                total = img[i][j]  # 当前单元格的值
                count = 1  # 计数器
                
                # 遍历 8 个方向
                for dx, dy in directions:
                    ni, nj = i + dx, j + dy
                    # 检查是否在边界内
                    if 0 <= ni < m and 0 <= nj < n:
                        total += img[ni][nj]
                        count += 1
                
                # 计算平均值（向下取整）
                result[i][j] = total // count
        
        return result
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$，其中 $m$ 和 $n$ 分别是图像的行数和列数。需要遍历每个单元格，每个单元格最多检查 8 个相邻单元格。
- **空间复杂度**：$O(m \times n)$，需要创建一个结果矩阵存储平滑后的图像。
