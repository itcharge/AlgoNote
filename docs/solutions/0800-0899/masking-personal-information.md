# [0831. 隐藏个人信息](https://leetcode.cn/problems/masking-personal-information/)

- 标签：字符串
- 难度：中等

## 题目链接

- [0831. 隐藏个人信息 - 力扣](https://leetcode.cn/problems/masking-personal-information/)

## 题目大意

**描述**：

给定一条个人信息字符串 $s$，可能表示一个「邮箱地址」，也可能表示一串「电话号码」。

一个「有效」的电子邮件地址由以下部分组成：

- 一个 `名字`，由大小写英文字母组成，后面跟着
- 一个 `'@'` 字符，后面跟着
- 一个 `域名`，由大小写英文字母和一个位于中间的 `'.'` 字符组成。`'.'` 不会是域名的第一个或者最后一个字符。

要想隐藏电子邮件地址中的个人信息：

- `名字` 和 `域名` 部分的大写英文字母应当转换成小写英文字母。
- `名字` 中间的字母（即，除第一个和最后一个字母外）必须用 5 个 `"*****"` 替换。

一个「有效」的电话号码应当按下述格式组成：

- 电话号码可以由 $10 \sim 13$ 位数字组成
- 后 10 位构成 本地号码
- 前面剩下的 $0 \sim 3$ 位，构成「国家代码」
- 利用 `{'+', '-', '(', ')', ' '}` 这些「分隔字符」按某种形式对上述数字进行分隔

要想隐藏电话号码中的个人信息：

- 移除所有 `分隔字符`
- 隐藏个人信息后的电话号码应该遵从这种格式：
   - `"***-***-XXXX"` 如果国家代码为 0 位数字
   - `"+*-***-***-XXXX"` 如果国家代码为 1 位数字
   - `"+**-***-***-XXXX"` 如果国家代码为 2 位数字
   - `"+***-***-***-XXXX"` 如果国家代码为 3 位数字
- `"XXXX"` 是最后 4 位 本地号码

**要求**：

返回按规则「隐藏」个人信息后的结果。

**说明**：

- $s$ 是一个「有效」的电子邮件或者电话号码。
- 如果 $s$ 是一个电子邮件：
   - $8 \le s.length \le 40$。
   - s 是由大小写英文字母，恰好一个 `'@'` 字符，以及 `'.'` 字符组成。
- 如果 $s$ 是一个电话号码：
   - $10 \le s.length \le 20$。
   - s 是由数字、空格、字符 `'('`、`')'`、`'-'` 和 `'+'` 组成。

**示例**：

- 示例 1：

```python
输入：s = "LeetCode@LeetCode.com"
输出："l*****e@leetcode.com"
解释：s 是一个电子邮件地址。
名字和域名都转换为小写，名字的中间用 5 个 * 替换。
```

- 示例 2：

```python
输入：s = "AB@qq.com"
输出："a*****b@qq.com"
解释：s 是一个电子邮件地址。
名字和域名都转换为小写，名字的中间用 5 个 * 替换。
注意，尽管 "ab" 只有两个字符，但中间仍然必须有 5 个 * 。
```

## 解题思路

### 思路 1：字符串处理 + 模拟

这道题要求根据规则隐藏个人信息。需要分别处理邮箱和电话号码两种情况。

**邮箱处理规则**：

1. 将名字和域名转换为小写。
2. 名字中间的字母用 $5$ 个 `*` 替换（保留首尾字母）。

**电话号码处理规则**：

1. 移除所有分隔字符，只保留数字。
2. 后 $10$ 位是本地号码，前面的是国家代码。
3. 根据国家代码位数格式化输出。

算法步骤：

1. 判断是邮箱还是电话号码（包含 `@` 则为邮箱）。
2. 根据类型应用相应的处理规则。

### 思路 1：代码

```python
class Solution:
    def maskPII(self, s: str) -> str:
        if '@' in s:
            # 处理邮箱
            s = s.lower()
            name, domain = s.split('@')
            # 名字首尾字母 + 5个* + 域名
            return name[0] + '*****' + name[-1] + '@' + domain
        else:
            # 处理电话号码
            # 移除所有非数字字符
            digits = ''.join(c for c in s if c.isdigit())
            
            # 本地号码是后 10 位
            local = digits[-10:]
            # 国家代码是前面的部分
            country_code_len = len(digits) - 10
            
            # 格式化本地号码
            masked_local = '***-***-' + local[-4:]
            
            # 根据国家代码位数添加前缀
            if country_code_len == 0:
                return masked_local
            else:
                return '+' + '*' * country_code_len + '-' + masked_local
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是字符串的长度。需要遍历字符串进行处理。
- **空间复杂度**：$O(n)$，需要存储处理后的字符串。
