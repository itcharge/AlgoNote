# [0789. 逃脱阻碍者](https://leetcode.cn/problems/escape-the-ghosts/)

- 标签：数组、数学
- 难度：中等

## 题目链接

- [0789. 逃脱阻碍者 - 力扣](https://leetcode.cn/problems/escape-the-ghosts/)

## 题目大意

**描述**：

你在进行一个简化版的吃豆人游戏。你从 $[0, 0]$ 点开始出发，你的目的地是 $target = [xtarget, ytarget]$。地图上有一些阻碍者，以数组 $ghosts$ 给出，第 $i$ 个阻碍者从 $ghosts[i] = [xi, yi]$ 出发。所有输入均为「整数坐标」。

每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 $1$ 个单位 的新位置。当然，也可以选择「不动」。所有动作「同时」发生。

如果你可以在任何阻碍者抓住你「之前」到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者「同时」到达了一个位置（包括目的地）「都不算」是逃脱成功。

**要求**：

如果不管阻碍者怎么移动都可以成功逃脱时，输出 true；否则，输出 false。

**说明**：

- $1 \le ghosts.length \le 10^{3}$。
- $ghosts[i].length == 2$。
- $-10^{4} \le xi, yi \le 10^{4}$。
- 同一位置可能有「多个阻碍者」。
- $target.length == 2$。
- $-10^{4} \le xtarget, ytarget \le 10^{4}$。

**示例**：

- 示例 1：

```python
输入：ghosts = [[1,0],[0,3]], target = [0,1]
输出：true
解释：你可以直接一步到达目的地 (0,1) ，在 (1, 0) 或者 (0, 3) 位置的阻碍者都不可能抓住你。
```

- 示例 2：

```python
输入：ghosts = [[1,0]], target = [2,0]
输出：false
解释：你需要走到位于 (2, 0) 的目的地，但是在 (1, 0) 的阻碍者位于你和目的地之间。
```

## 解题思路

### 思路 1：曼哈顿距离

这道题的关键在于理解：如果阻碍者能在你之前或同时到达目的地，你就无法逃脱。

**核心观察**：

- 你和阻碍者都使用曼哈顿距离移动。
- 从 $(x_1, y_1)$ 到 $(x_2, y_2)$ 的曼哈顿距离为 $|x_1 - x_2| + |y_1 - y_2|$。
- 如果存在任何一个阻碍者到目的地的距离 $\leq$ 你到目的地的距离，你就无法逃脱。
- 因为阻碍者可以采取最优策略，直接朝目的地移动。

**解题步骤**：

1. 计算你从起点 $(0, 0)$ 到目的地 $target$ 的曼哈顿距离。
2. 对于每个阻碍者，计算其到目的地的曼哈顿距离。
3. 如果所有阻碍者到目的地的距离都严格大于你的距离，返回 `True`。
4. 否则返回 `False`。

### 思路 1：代码

```python
class Solution:
    def escapeGhosts(self, ghosts: List[List[int]], target: List[int]) -> bool:
        # 计算你到目的地的曼哈顿距离
        my_distance = abs(target[0]) + abs(target[1])
        
        # 检查每个阻碍者到目的地的距离
        for ghost in ghosts:
            ghost_distance = abs(ghost[0] - target[0]) + abs(ghost[1] - target[1])
            # 如果任何阻碍者能在你之前或同时到达，返回 False
            if ghost_distance <= my_distance:
                return False
        
        return True
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是阻碍者的数量。需要遍历所有阻碍者。
- **空间复杂度**：$O(1)$。只使用了常数个额外变量。
