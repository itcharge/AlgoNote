# [0799. 香槟塔](https://leetcode.cn/problems/champagne-tower/)

- 标签：动态规划
- 难度：中等

## 题目链接

- [0799. 香槟塔 - 力扣](https://leetcode.cn/problems/champagne-tower/)

## 题目大意

**描述**：

我们把玻璃杯摆成金字塔的形状，其中第一层有 $1$ 个玻璃杯，第二层有 $2$ 个，依次类推到第 $100$ 层，每个玻璃杯将盛有香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png)

**要求**：

现在当倾倒了非负整数杯香槟后，返回第 $i$ 行 $j$ 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ $i$ 和 $j$ 都从 $0$ 开始）。

**说明**：

- $0 \le poured \le 10^{9}$。
- $0 \le query\_glass \le query\_row \lt 10^{3}$。

**示例**：

- 示例 1：

```python
示例 1:
输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.00000
解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。
```

- 示例 2：

```python
输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.50000
解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。
```

## 解题思路

### 思路 1：动态规划 + 模拟

这道题可以使用动态规划来模拟香槟倾倒的过程。

**解题步骤**：

1. 定义 $dp[i][j]$ 表示第 $i$ 行第 $j$ 个杯子中的香槟量（可能超过 $1$）。
2. 初始时，将所有香槟倒入顶层杯子：$dp[0][0] = poured$。
3. 对于每个杯子 $dp[i][j]$：
   - 如果 $dp[i][j] > 1$，说明有香槟溢出。
   - 溢出的香槟量为 $overflow = (dp[i][j] - 1) / 2$。
   - 将溢出的香槟平均分配给下一层的两个杯子：$dp[i+1][j]$ 和 $dp[i+1][j+1]$。
4. 最后返回 $\min(1, dp[query\_row][query\_glass])$，因为杯子最多只能装 $1$ 杯香槟。

**优化**：由于只需要计算到第 $query\_row$ 行，所以只需要模拟到该行即可。

### 思路 1：代码

```python
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        # dp[i][j] 表示第 i 行第 j 个杯子中的香槟量
        dp = [[0.0] * (query_row + 2) for _ in range(query_row + 2)]
        dp[0][0] = poured
        
        # 模拟香槟倾倒过程
        for i in range(query_row + 1):
            for j in range(i + 1):
                if dp[i][j] > 1:
                    # 计算溢出的香槟量
                    overflow = (dp[i][j] - 1) / 2.0
                    # 将溢出的香槟平均分配给下一层的两个杯子
                    dp[i + 1][j] += overflow
                    dp[i + 1][j + 1] += overflow
        
        # 返回目标杯子中的香槟量，最多为 1
        return min(1.0, dp[query_row][query_glass])
```

### 思路 1：复杂度分析

- **时间复杂度**：$O(query\_row^2)$。需要遍历前 $query\_row + 1$ 行的所有杯子。
- **空间复杂度**：$O(query\_row^2)$。需要存储前 $query\_row + 1$ 行的所有杯子的状态。
